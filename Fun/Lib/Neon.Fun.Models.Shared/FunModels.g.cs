//-----------------------------------------------------------------------------
// FILE: FunModels.g.cs
//
// This file was generated by the Neon [entity-gen] build tool.
// Any manual edits will be lost when the file is regenerated.

#pragma warning disable 1591

using System;
using System.Collections.Generic;
using System.Dynamic;
using System.IO;

using Newtonsoft.Json.Linq;

using Couchbase.Lite;

using Neon.Stack.Common;
using Neon.Stack.Data;
using Neon.Stack.Data.Internal;

//-----------------------------------------------------------------------------

#region Entities


namespace Neon.Fun
{
    public partial class Account : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.account";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "enabled", "IsEnabled" },
                { "@person", "Person" },
                { "roles", "Roles" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Account), "nf.account",
                (jObject, context) =>
                {
                    return new Account(jObject, context);
                });
        }

        public static bool operator ==(Account entity1, Account entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Account entity1, Account entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<bool>                 _IsEnabled;
        private LinkMapper<Neon.Fun.Models.Person> _Person;
        private ListMapper<string>                 _Roles;

        public Account()
            : this(new JObject())
        {
        }

        public Account(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _IsEnabled = new SimpleMapper<bool>(this, "enabled", "IsEnabled", context);
            _Person    = new LinkMapper<Neon.Fun.Models.Person>(this, "@person", "Person", context);
            _Roles     = new ListMapper<string>(this, "roles", "Roles", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Account; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<bool>(ref _IsEnabled, reload) || changed;
            changed = base.MapProperty<Neon.Fun.Models.Person>(ref _Person, reload) || changed;
            changed = base.MapProperty<string>(ref _Roles, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Account)obj;

            if (other == null)
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.IsEnabled != other.IsEnabled)
            {
                return false;
            }

            if (this._Person.Link != other._Person.Link)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Roles, other.Roles))
            {
                return false;
            }

            return true;
        }

        public bool IsEnabled
        {
            get { return _IsEnabled.Value; }
            set { _IsEnabled.Value = value; }
        }

        public Neon.Fun.Models.Person Person
        {
            get { return _Person.Value; }
            set { _Person.Value = value; }
        }

        public IList<string> Roles
        {
            get { return _Roles.Value; }
            set { _Roles.Set(value); }
        }
    }
}

namespace Neon.Fun.Bowling
{
    public partial class BallSummary : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.bowl.ballspec";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "color", "Color" },
                { "coverstock", "CoverStock" },
                { "color", "Fagrance" },
                { "finish", "Finish" },
                { "retired", "IsRetired" },
                { "manufacturer", "Manufacturer" },
                { "model", "Model" },
                { "release_date", "ReleaseDate" },
                { "detail", "Weights" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(BallSummary), "nf.bowl.ballspec",
                (jObject, context) =>
                {
                    return new BallSummary(jObject, context);
                });
        }

        public static bool operator ==(BallSummary entity1, BallSummary entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(BallSummary entity1, BallSummary entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<string>   _Color;
        private SimpleMapper<string>   _CoverStock;
        private SimpleMapper<string>   _Fagrance;
        private SimpleMapper<string>   _Finish;
        private SimpleMapper<bool>     _IsRetired;
        private SimpleMapper<string>   _Manufacturer;
        private SimpleMapper<string>   _Model;
        private SimpleMapper<DateTime> _ReleaseDate;
        private ListMapper<int>        _Weights;

        public BallSummary()
            : this(new JObject())
        {
        }

        public BallSummary(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _Color        = new SimpleMapper<string>(this, "color", "Color", context);
            _CoverStock   = new SimpleMapper<string>(this, "coverstock", "CoverStock", context);
            _Fagrance     = new SimpleMapper<string>(this, "color", "Fagrance", context);
            _Finish       = new SimpleMapper<string>(this, "finish", "Finish", context);
            _IsRetired    = new SimpleMapper<bool>(this, "retired", "IsRetired", context);
            _Manufacturer = new SimpleMapper<string>(this, "manufacturer", "Manufacturer", context);
            _Model        = new SimpleMapper<string>(this, "model", "Model", context);
            _ReleaseDate  = new SimpleMapper<DateTime>(this, "release_date", "ReleaseDate", context);
            _Weights      = new ListMapper<int>(this, "detail", "Weights", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<string>(ref _Color, reload) || changed;
            changed = base.MapProperty<string>(ref _CoverStock, reload) || changed;
            changed = base.MapProperty<string>(ref _Fagrance, reload) || changed;
            changed = base.MapProperty<string>(ref _Finish, reload) || changed;
            changed = base.MapProperty<bool>(ref _IsRetired, reload) || changed;
            changed = base.MapProperty<string>(ref _Manufacturer, reload) || changed;
            changed = base.MapProperty<string>(ref _Model, reload) || changed;
            changed = base.MapProperty<DateTime>(ref _ReleaseDate, reload) || changed;
            changed = base.MapProperty<int>(ref _Weights, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Bowling.BallSummary)obj;

            if (other == null)
            {
                return false;
            }

            if (this.Color != other.Color)
            {
                return false;
            }

            if (this.CoverStock != other.CoverStock)
            {
                return false;
            }

            if (this.Fagrance != other.Fagrance)
            {
                return false;
            }

            if (this.Finish != other.Finish)
            {
                return false;
            }

            if (this.IsRetired != other.IsRetired)
            {
                return false;
            }

            if (this.Manufacturer != other.Manufacturer)
            {
                return false;
            }

            if (this.Model != other.Model)
            {
                return false;
            }

            if (this.ReleaseDate != other.ReleaseDate)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Weights, other.Weights))
            {
                return false;
            }

            return true;
        }

        public string Color
        {
            get { return _Color.Value; }
            set { _Color.Value = value; }
        }

        public string CoverStock
        {
            get { return _CoverStock.Value; }
            set { _CoverStock.Value = value; }
        }

        public string Fagrance
        {
            get { return _Fagrance.Value; }
            set { _Fagrance.Value = value; }
        }

        public string Finish
        {
            get { return _Finish.Value; }
            set { _Finish.Value = value; }
        }

        public bool IsRetired
        {
            get { return _IsRetired.Value; }
            set { _IsRetired.Value = value; }
        }

        public string Manufacturer
        {
            get { return _Manufacturer.Value; }
            set { _Manufacturer.Value = value; }
        }

        public string Model
        {
            get { return _Model.Value; }
            set { _Model.Value = value; }
        }

        public DateTime ReleaseDate
        {
            get { return _ReleaseDate.Value; }
            set { _ReleaseDate.Value = value; }
        }

        public IList<int> Weights
        {
            get { return _Weights.Value; }
            set { _Weights.Set(value); }
        }
    }
}

namespace Neon.Fun.Bowling
{
    public partial class BowlingCenter : Neon.Fun.Organization
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.bowl.center";
        private const string typePathString = "nf.bowl.center:nf.org";

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "addresses", "Addresses" },
                { "@children", "Children" },
                { "id", "Id" },
                { "enabled", "IsEnabled" },
                { "lanes", "Lanes" },
                { "name", "Name" },
                { "@parents", "Parents" },
                { "@users", "Users" },
            };

        public static new EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(BowlingCenter), "nf.bowl.center",
                (jObject, context) =>
                {
                    return new BowlingCenter(jObject, context);
                });
        }

        public static bool operator ==(BowlingCenter entity1, BowlingCenter entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(BowlingCenter entity1, BowlingCenter entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private EntityListMapper<Neon.Fun.Bowling.Lane> _Lanes;

        public BowlingCenter()
            : this(new JObject())
        {
        }

        public BowlingCenter(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(jObject, context: context, load: false, derivedPropertyNameMap: derivedPropertyNameMap)
        {
            _Lanes = new EntityListMapper<Neon.Fun.Bowling.Lane>(this, "lanes", "Lanes", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.BowlingCenter; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            changed = base._Load(jObject, reload, setType: false);
            changed = base.MapProperty<Neon.Fun.Bowling.Lane>(ref _Lanes, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (!base.Equals(obj))
            {
                return false;
            }

            var other = (Neon.Fun.Bowling.BowlingCenter)obj;

            if (other == null)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Lanes, other.Lanes))
            {
                return false;
            }

            return true;
        }

        public IList<Neon.Fun.Bowling.Lane> Lanes
        {
            get { return _Lanes.Value; }
            set { _Lanes.Set(value); }
        }
    }
}

namespace Neon.Fun.Bowling
{
    public partial class Lane : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.bowl.lane";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "number", "Number" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Lane), "nf.bowl.lane",
                (jObject, context) =>
                {
                    return new Lane(jObject, context);
                });
        }

        public static bool operator ==(Lane entity1, Lane entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Lane entity1, Lane entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<int> _Number;

        public Lane()
            : this(new JObject())
        {
        }

        public Lane(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _Number = new SimpleMapper<int>(this, "number", "Number", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<int>(ref _Number, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Bowling.Lane)obj;

            if (other == null)
            {
                return false;
            }

            if (this.Number != other.Number)
            {
                return false;
            }

            return true;
        }

        public int Number
        {
            get { return _Number.Value; }
            set { _Number.Value = value; }
        }
    }
}

namespace Neon.Fun.Bowling
{
    public partial class League : Neon.Fun.Organization
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.bowl.league";
        private const string typePathString = "nf.bowl.league:nf.org";

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "addresses", "Addresses" },
                { "@children", "Children" },
                { "id", "Id" },
                { "enabled", "IsEnabled" },
                { "name", "Name" },
                { "@parents", "Parents" },
                { "@users", "Users" },
            };

        public static new EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(League), "nf.bowl.league",
                (jObject, context) =>
                {
                    return new League(jObject, context);
                });
        }

        public static bool operator ==(League entity1, League entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(League entity1, League entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        public League()
            : this(new JObject())
        {
        }

        public League(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(jObject, context: context, load: false, derivedPropertyNameMap: derivedPropertyNameMap)
        {

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.BowlingLeague; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            changed = base._Load(jObject, reload, setType: false);

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (!base.Equals(obj))
            {
                return false;
            }

            var other = (Neon.Fun.Bowling.League)obj;

            if (other == null)
            {
                return false;
            }

            return true;
        }
    }
}

namespace Neon.Fun.Bowling
{
    public partial class ProShop : Neon.Fun.Organization
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.bowl.proshop";
        private const string typePathString = "nf.bowl.proshop:nf.org";

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "Accounts", "Accounts" },
                { "addresses", "Addresses" },
                { "@children", "Children" },
                { "id", "Id" },
                { "enabled", "IsEnabled" },
                { "name", "Name" },
                { "@parents", "Parents" },
                { "@users", "Users" },
            };

        public static new EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(ProShop), "nf.bowl.proshop",
                (jObject, context) =>
                {
                    return new ProShop(jObject, context);
                });
        }

        public static bool operator ==(ProShop entity1, ProShop entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(ProShop entity1, ProShop entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private EntityListMapper<Neon.Fun.Account> _Accounts;

        public ProShop()
            : this(new JObject())
        {
        }

        public ProShop(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(jObject, context: context, load: false, derivedPropertyNameMap: derivedPropertyNameMap)
        {
            _Accounts = new EntityListMapper<Neon.Fun.Account>(this, "Accounts", "Accounts", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.BowlingProShop; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            changed = base._Load(jObject, reload, setType: false);
            changed = base.MapProperty<Neon.Fun.Account>(ref _Accounts, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (!base.Equals(obj))
            {
                return false;
            }

            var other = (Neon.Fun.Bowling.ProShop)obj;

            if (other == null)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Accounts, other.Accounts))
            {
                return false;
            }

            return true;
        }

        public IList<Neon.Fun.Account> Accounts
        {
            get { return _Accounts.Value; }
            set { _Accounts.Set(value); }
        }
    }
}

namespace Neon.Fun
{
    public partial class Casino : Neon.Fun.Organization
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.casino";
        private const string typePathString = "nf.casino:nf.org";

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "addresses", "Addresses" },
                { "@children", "Children" },
                { "id", "Id" },
                { "enabled", "IsEnabled" },
                { "name", "Name" },
                { "@parents", "Parents" },
                { "@users", "Users" },
            };

        public static new EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Casino), "nf.casino",
                (jObject, context) =>
                {
                    return new Casino(jObject, context);
                });
        }

        public static bool operator ==(Casino entity1, Casino entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Casino entity1, Casino entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        public Casino()
            : this(new JObject())
        {
        }

        public Casino(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(jObject, context: context, load: false, derivedPropertyNameMap: derivedPropertyNameMap)
        {

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Casino; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            changed = base._Load(jObject, reload, setType: false);

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (!base.Equals(obj))
            {
                return false;
            }

            var other = (Neon.Fun.Casino)obj;

            if (other == null)
            {
                return false;
            }

            return true;
        }
    }
}

namespace Neon.Fun
{
    public partial class Customer : Neon.Fun.Account
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.customer";
        private const string typePathString = "nf.customer:nf.account";

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "enabled", "IsEnabled" },
                { "@person", "Person" },
                { "roles", "Roles" },
            };

        public static new EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Customer), "nf.customer",
                (jObject, context) =>
                {
                    return new Customer(jObject, context);
                });
        }

        public static bool operator ==(Customer entity1, Customer entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Customer entity1, Customer entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        public Customer()
            : this(new JObject())
        {
        }

        public Customer(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(jObject, context: context, load: false, derivedPropertyNameMap: derivedPropertyNameMap)
        {

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Customer; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            changed = base._Load(jObject, reload, setType: false);

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (!base.Equals(obj))
            {
                return false;
            }

            var other = (Neon.Fun.Customer)obj;

            if (other == null)
            {
                return false;
            }

            return true;
        }
    }
}

namespace Neon.Fun
{
    public partial class Email : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.email";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "address", "Address" },
                { "use", "Use" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Email), "nf.email",
                (jObject, context) =>
                {
                    return new Email(jObject, context);
                });
        }

        public static bool operator ==(Email entity1, Email entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Email entity1, Email entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<string>             _Address;
        private SimpleMapper<Neon.Fun.EmailUses> _Use;

        public Email()
            : this(new JObject())
        {
        }

        public Email(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _Address = new SimpleMapper<string>(this, "address", "Address", context);
            _Use     = new SimpleMapper<Neon.Fun.EmailUses>(this, "use", "Use", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Email; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<string>(ref _Address, reload) || changed;
            changed = base.MapProperty<Neon.Fun.EmailUses>(ref _Use, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Email)obj;

            if (other == null)
            {
                return false;
            }

            if (this.Address != other.Address)
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.Use != other.Use)
            {
                return false;
            }

            return true;
        }

        public string Address
        {
            get { return _Address.Value; }
            set { _Address.Value = value; }
        }

        public Neon.Fun.EmailUses Use
        {
            get { return _Use.Value; }
            set { _Use.Value = value; }
        }
    }
}

namespace Neon.Fun
{
    public partial class Employee : Neon.Fun.Account
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.employee";
        private const string typePathString = "nf.employee:nf.account";

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "enabled", "IsEnabled" },
                { "@person", "Person" },
                { "roles", "Roles" },
            };

        public static new EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Employee), "nf.employee",
                (jObject, context) =>
                {
                    return new Employee(jObject, context);
                });
        }

        public static bool operator ==(Employee entity1, Employee entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Employee entity1, Employee entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        public Employee()
            : this(new JObject())
        {
        }

        public Employee(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(jObject, context: context, load: false, derivedPropertyNameMap: derivedPropertyNameMap)
        {

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Employee; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            changed = base._Load(jObject, reload, setType: false);

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (!base.Equals(obj))
            {
                return false;
            }

            var other = (Neon.Fun.Employee)obj;

            if (other == null)
            {
                return false;
            }

            return true;
        }
    }
}

namespace Neon.Fun
{
    public partial class LatLon : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.lat_lon";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "Lat", "Lat" },
                { "Lon", "Lon" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(LatLon), "nf.lat_lon",
                (jObject, context) =>
                {
                    return new LatLon(jObject, context);
                });
        }

        public static bool operator ==(LatLon entity1, LatLon entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(LatLon entity1, LatLon entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<double> _Lat;
        private SimpleMapper<double> _Lon;

        public LatLon()
            : this(new JObject())
        {
        }

        public LatLon(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _Lat = new SimpleMapper<double>(this, "Lat", "Lat", context);
            _Lon = new SimpleMapper<double>(this, "Lon", "Lon", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.LatLon; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<double>(ref _Lat, reload) || changed;
            changed = base.MapProperty<double>(ref _Lon, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.LatLon)obj;

            if (other == null)
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.Lat != other.Lat)
            {
                return false;
            }

            if (this.Lon != other.Lon)
            {
                return false;
            }

            return true;
        }

        public double Lat
        {
            get { return _Lat.Value; }
            set { _Lat.Value = value; }
        }

        public double Lon
        {
            get { return _Lon.Value; }
            set { _Lon.Value = value; }
        }
    }
}

namespace Neon.Fun
{
    public partial class Location : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.location";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "box_number", "BoxNumber" },
                { "coordinates", "Coordinates" },
                { "country_code", "CountryCode" },
                { "locality", "Locality" },
                { "postal_code", "PostalCode" },
                { "region", "Region" },
                { "street1", "Street1" },
                { "street2", "Street2" },
                { "uses", "Uses" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Location), "nf.location",
                (jObject, context) =>
                {
                    return new Location(jObject, context);
                });
        }

        public static bool operator ==(Location entity1, Location entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Location entity1, Location entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<string>              _BoxNumber;
        private EntityMapper<Neon.Fun.LatLon>     _Coordinates;
        private SimpleMapper<string>              _CountryCode;
        private SimpleMapper<string>              _Locality;
        private SimpleMapper<string>              _PostalCode;
        private SimpleMapper<string>              _Region;
        private SimpleMapper<string>              _Street1;
        private SimpleMapper<string>              _Street2;
        private ListMapper<Neon.Fun.LocationUses> _Uses;

        public Location()
            : this(new JObject())
        {
        }

        public Location(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _BoxNumber   = new SimpleMapper<string>(this, "box_number", "BoxNumber", context);
            _Coordinates = new EntityMapper<Neon.Fun.LatLon>(this, "coordinates", "Coordinates", context);
            _CountryCode = new SimpleMapper<string>(this, "country_code", "CountryCode", context);
            _Locality    = new SimpleMapper<string>(this, "locality", "Locality", context);
            _PostalCode  = new SimpleMapper<string>(this, "postal_code", "PostalCode", context);
            _Region      = new SimpleMapper<string>(this, "region", "Region", context);
            _Street1     = new SimpleMapper<string>(this, "street1", "Street1", context);
            _Street2     = new SimpleMapper<string>(this, "street2", "Street2", context);
            _Uses        = new ListMapper<Neon.Fun.LocationUses>(this, "uses", "Uses", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Location; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<string>(ref _BoxNumber, reload) || changed;
            changed = base.MapProperty<Neon.Fun.LatLon>(ref _Coordinates, reload) || changed;
            changed = base.MapProperty<string>(ref _CountryCode, reload) || changed;
            changed = base.MapProperty<string>(ref _Locality, reload) || changed;
            changed = base.MapProperty<string>(ref _PostalCode, reload) || changed;
            changed = base.MapProperty<string>(ref _Region, reload) || changed;
            changed = base.MapProperty<string>(ref _Street1, reload) || changed;
            changed = base.MapProperty<string>(ref _Street2, reload) || changed;
            changed = base.MapProperty<Neon.Fun.LocationUses>(ref _Uses, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Location)obj;

            if (other == null)
            {
                return false;
            }

            if (this.BoxNumber != other.BoxNumber)
            {
                return false;
            }

            if (this.Coordinates != other.Coordinates)
            {
                return false;
            }

            if (this.CountryCode != other.CountryCode)
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.Locality != other.Locality)
            {
                return false;
            }

            if (this.PostalCode != other.PostalCode)
            {
                return false;
            }

            if (this.Region != other.Region)
            {
                return false;
            }

            if (this.Street1 != other.Street1)
            {
                return false;
            }

            if (this.Street2 != other.Street2)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Uses, other.Uses))
            {
                return false;
            }

            return true;
        }

        public string BoxNumber
        {
            get { return _BoxNumber.Value; }
            set { _BoxNumber.Value = value; }
        }

        public Neon.Fun.LatLon Coordinates
        {
            get { return _Coordinates.Value; }
            set { _Coordinates.Value = value; }
        }

        public string CountryCode
        {
            get { return _CountryCode.Value; }
            set { _CountryCode.Value = value; }
        }

        public string Locality
        {
            get { return _Locality.Value; }
            set { _Locality.Value = value; }
        }

        public string PostalCode
        {
            get { return _PostalCode.Value; }
            set { _PostalCode.Value = value; }
        }

        public string Region
        {
            get { return _Region.Value; }
            set { _Region.Value = value; }
        }

        public string Street1
        {
            get { return _Street1.Value; }
            set { _Street1.Value = value; }
        }

        public string Street2
        {
            get { return _Street2.Value; }
            set { _Street2.Value = value; }
        }

        public IList<Neon.Fun.LocationUses> Uses
        {
            get { return _Uses.Value; }
            set { _Uses.Set(value); }
        }
    }
}

namespace Neon.Fun.Models
{
    public partial class Person : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.person";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "emails", "Emails" },
                { "first", "First" },
                { "id", "Id" },
                { "enabled", "IsEnabled" },
                { "last", "Last" },
                { "phones", "Phones" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Person), "nf.person",
                (jObject, context) =>
                {
                    return new Person(jObject, context);
                });
        }

        public static bool operator ==(Person entity1, Person entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Person entity1, Person entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private EntityListMapper<Neon.Fun.Email> _Emails;
        private SimpleMapper<string>             _First;
        private SimpleMapper<string>             _Id;
        private SimpleMapper<bool>               _IsEnabled;
        private SimpleMapper<string>             _Last;
        private EntityListMapper<Neon.Fun.Phone> _Phones;

        public Person()
            : this(new JObject())
        {
        }

        public Person(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _Emails    = new EntityListMapper<Neon.Fun.Email>(this, "emails", "Emails", context);
            _First     = new SimpleMapper<string>(this, "first", "First", context);
            _Id        = new SimpleMapper<string>(this, "id", "Id", context);
            _IsEnabled = new SimpleMapper<bool>(this, "enabled", "IsEnabled", context);
            _Last      = new SimpleMapper<string>(this, "last", "Last", context);
            _Phones    = new EntityListMapper<Neon.Fun.Phone>(this, "phones", "Phones", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Person; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<Neon.Fun.Email>(ref _Emails, reload) || changed;
            changed = base.MapProperty<string>(ref _First, reload) || changed;
            changed = base.MapProperty<string>(ref _Id, reload) || changed;
            changed = base.MapProperty<bool>(ref _IsEnabled, reload) || changed;
            changed = base.MapProperty<string>(ref _Last, reload) || changed;
            changed = base.MapProperty<Neon.Fun.Phone>(ref _Phones, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Models.Person)obj;

            if (other == null)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Emails, other.Emails))
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.First != other.First)
            {
                return false;
            }

            if (this.Id != other.Id)
            {
                return false;
            }

            if (this.IsEnabled != other.IsEnabled)
            {
                return false;
            }

            if (this.Last != other.Last)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Phones, other.Phones))
            {
                return false;
            }

            return true;
        }

        public IList<Neon.Fun.Email> Emails
        {
            get { return _Emails.Value; }
            set { _Emails.Set(value); }
        }

        public string First
        {
            get { return _First.Value; }
            set { _First.Value = value; }
        }

        public string Id
        {
            get { return _Id.Value; }
            set { _Id.Value = value; }
        }

        public bool IsEnabled
        {
            get { return _IsEnabled.Value; }
            set { _IsEnabled.Value = value; }
        }

        public string Last
        {
            get { return _Last.Value; }
            set { _Last.Value = value; }
        }

        public IList<Neon.Fun.Phone> Phones
        {
            get { return _Phones.Value; }
            set { _Phones.Set(value); }
        }
    }
}

namespace Neon.Fun
{
    public partial class Organization : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.org";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "addresses", "Addresses" },
                { "@children", "Children" },
                { "id", "Id" },
                { "enabled", "IsEnabled" },
                { "name", "Name" },
                { "@parents", "Parents" },
                { "@users", "Users" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Organization), "nf.org",
                (jObject, context) =>
                {
                    return new Organization(jObject, context);
                });
        }

        public static bool operator ==(Organization entity1, Organization entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Organization entity1, Organization entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private EntityListMapper<Neon.Fun.Location>   _Addresses;
        private LinkListMapper<Neon.Fun.Organization> _Children;
        private SimpleMapper<string>                  _Id;
        private SimpleMapper<bool>                    _IsEnabled;
        private SimpleMapper<string>                  _Name;
        private LinkListMapper<Neon.Fun.Organization> _Parents;
        private LinkListMapper<Neon.Fun.Account>      _Users;

        public Organization()
            : this(new JObject())
        {
        }

        public Organization(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _Addresses = new EntityListMapper<Neon.Fun.Location>(this, "addresses", "Addresses", context);
            _Children  = new LinkListMapper<Neon.Fun.Organization>(this, "@children", "Children", context);
            _Id        = new SimpleMapper<string>(this, "id", "Id", context);
            _IsEnabled = new SimpleMapper<bool>(this, "enabled", "IsEnabled", context);
            _Name      = new SimpleMapper<string>(this, "name", "Name", context);
            _Parents   = new LinkListMapper<Neon.Fun.Organization>(this, "@parents", "Parents", context);
            _Users     = new LinkListMapper<Neon.Fun.Account>(this, "@users", "Users", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Organization; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<Neon.Fun.Location>(ref _Addresses, reload) || changed;
            changed = base.MapProperty<Neon.Fun.Organization>(ref _Children, reload) || changed;
            changed = base.MapProperty<string>(ref _Id, reload) || changed;
            changed = base.MapProperty<bool>(ref _IsEnabled, reload) || changed;
            changed = base.MapProperty<string>(ref _Name, reload) || changed;
            changed = base.MapProperty<Neon.Fun.Organization>(ref _Parents, reload) || changed;
            changed = base.MapProperty<Neon.Fun.Account>(ref _Users, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Organization)obj;

            if (other == null)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Addresses, other.Addresses))
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Children, other.Children))
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.Id != other.Id)
            {
                return false;
            }

            if (this.IsEnabled != other.IsEnabled)
            {
                return false;
            }

            if (this.Name != other.Name)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Parents, other.Parents))
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Users, other.Users))
            {
                return false;
            }

            return true;
        }

        public IList<Neon.Fun.Location> Addresses
        {
            get { return _Addresses.Value; }
            set { _Addresses.Set(value); }
        }

        public IList<Neon.Fun.Organization> Children
        {
            get { return _Children.Value; }
            set { _Children.Set(value); }
        }

        public string Id
        {
            get { return _Id.Value; }
            set { _Id.Value = value; }
        }

        public bool IsEnabled
        {
            get { return _IsEnabled.Value; }
            set { _IsEnabled.Value = value; }
        }

        public string Name
        {
            get { return _Name.Value; }
            set { _Name.Value = value; }
        }

        public IList<Neon.Fun.Organization> Parents
        {
            get { return _Parents.Value; }
            set { _Parents.Set(value); }
        }

        public IList<Neon.Fun.Account> Users
        {
            get { return _Users.Value; }
            set { _Users.Set(value); }
        }
    }
}

namespace Neon.Fun
{
    public partial class Phone : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.phone";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "mobile", "IsMobile" },
                { "number", "Number" },
                { "use", "Use" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Phone), "nf.phone",
                (jObject, context) =>
                {
                    return new Phone(jObject, context);
                });
        }

        public static bool operator ==(Phone entity1, Phone entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Phone entity1, Phone entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<bool>               _IsMobile;
        private SimpleMapper<string>             _Number;
        private SimpleMapper<Neon.Fun.PhoneUses> _Use;

        public Phone()
            : this(new JObject())
        {
        }

        public Phone(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _IsMobile = new SimpleMapper<bool>(this, "mobile", "IsMobile", context);
            _Number   = new SimpleMapper<string>(this, "number", "Number", context);
            _Use      = new SimpleMapper<Neon.Fun.PhoneUses>(this, "use", "Use", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Phone; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<bool>(ref _IsMobile, reload) || changed;
            changed = base.MapProperty<string>(ref _Number, reload) || changed;
            changed = base.MapProperty<Neon.Fun.PhoneUses>(ref _Use, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Phone)obj;

            if (other == null)
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.IsMobile != other.IsMobile)
            {
                return false;
            }

            if (this.Number != other.Number)
            {
                return false;
            }

            if (this.Use != other.Use)
            {
                return false;
            }

            return true;
        }

        public bool IsMobile
        {
            get { return _IsMobile.Value; }
            set { _IsMobile.Value = value; }
        }

        public string Number
        {
            get { return _Number.Value; }
            set { _Number.Value = value; }
        }

        public Neon.Fun.PhoneUses Use
        {
            get { return _Use.Value; }
            set { _Use.Value = value; }
        }
    }
}

namespace Neon.Fun
{
    public partial class Restaurant : Neon.Fun.Organization
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.restaurant";
        private const string typePathString = "nf.restaurant:nf.org";

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "addresses", "Addresses" },
                { "@children", "Children" },
                { "id", "Id" },
                { "enabled", "IsEnabled" },
                { "name", "Name" },
                { "@parents", "Parents" },
                { "@users", "Users" },
            };

        public static new EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Restaurant), "nf.restaurant",
                (jObject, context) =>
                {
                    return new Restaurant(jObject, context);
                });
        }

        public static bool operator ==(Restaurant entity1, Restaurant entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Restaurant entity1, Restaurant entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        public Restaurant()
            : this(new JObject())
        {
        }

        public Restaurant(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(jObject, context: context, load: false, derivedPropertyNameMap: derivedPropertyNameMap)
        {

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Restaurant; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            changed = base._Load(jObject, reload, setType: false);

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            if (!base.Equals(obj))
            {
                return false;
            }

            var other = (Neon.Fun.Restaurant)obj;

            if (other == null)
            {
                return false;
            }

            return true;
        }
    }
}

namespace Neon.Fun.Signage
{
    public partial class SignageContentPlayList : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.sign.content.playlist";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "end", "EndTimeUtc" },
                { "list", "List" },
                { "start", "StartTimeUtc" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(SignageContentPlayList), "nf.sign.content.playlist",
                (jObject, context) =>
                {
                    return new SignageContentPlayList(jObject, context);
                });
        }

        public static bool operator ==(SignageContentPlayList entity1, SignageContentPlayList entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(SignageContentPlayList entity1, SignageContentPlayList entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<DateTime>                                 _EndTimeUtc;
        private DocListMapper<Neon.Fun.Signage.SignageContentDocument> _List;
        private SimpleMapper<DateTime>                                 _StartTimeUtc;

        public SignageContentPlayList()
            : this(new JObject())
        {
        }

        public SignageContentPlayList(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _EndTimeUtc   = new SimpleMapper<DateTime>(this, "end", "EndTimeUtc", context);
            _List         = new DocListMapper<Neon.Fun.Signage.SignageContentDocument>(this, "list", "List", context);
            _StartTimeUtc = new SimpleMapper<DateTime>(this, "start", "StartTimeUtc", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<DateTime>(ref _EndTimeUtc, reload) || changed;
            changed = base.MapProperty<Neon.Fun.Signage.SignageContentDocument>(ref _List, reload) || changed;
            changed = base.MapProperty<DateTime>(ref _StartTimeUtc, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Signage.SignageContentPlayList)obj;

            if (other == null)
            {
                return false;
            }

            if (this.EndTimeUtc != other.EndTimeUtc)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.List, other.List))
            {
                return false;
            }

            if (this.StartTimeUtc != other.StartTimeUtc)
            {
                return false;
            }

            return true;
        }

        public DateTime EndTimeUtc
        {
            get { return _EndTimeUtc.Value; }
            set { _EndTimeUtc.Value = value; }
        }

        public IList<Neon.Fun.Signage.SignageContentDocument> List
        {
            get { return _List.Value; }
            set { _List.Set(value); }
        }

        public DateTime StartTimeUtc
        {
            get { return _StartTimeUtc.Value; }
            set { _StartTimeUtc.Value = value; }
        }
    }
}

namespace Neon.Fun.Signage
{
    public partial class SignageContentProperties : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.sign.content.properties";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "content_type", "ContentType" },
                { "enabled", "IsEnabled" },
                { "min_player", "MinimumPlayerVersion" },
                { "run_time", "RunTime" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(SignageContentProperties), "nf.sign.content.properties",
                (jObject, context) =>
                {
                    return new SignageContentProperties(jObject, context);
                });
        }

        public static bool operator ==(SignageContentProperties entity1, SignageContentProperties entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(SignageContentProperties entity1, SignageContentProperties entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private SimpleMapper<Neon.Fun.Signage.SignageContentType> _ContentType;
        private SimpleMapper<bool>                                _IsEnabled;
        private SimpleMapper<string>                              _MinimumPlayerVersion;
        private SimpleMapper<TimeSpan>                            _RunTime;

        public SignageContentProperties()
            : this(new JObject())
        {
        }

        public SignageContentProperties(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _ContentType          = new SimpleMapper<Neon.Fun.Signage.SignageContentType>(this, "content_type", "ContentType", context);
            _IsEnabled            = new SimpleMapper<bool>(this, "enabled", "IsEnabled", context);
            _MinimumPlayerVersion = new SimpleMapper<string>(this, "min_player", "MinimumPlayerVersion", context);
            _RunTime              = new SimpleMapper<TimeSpan>(this, "run_time", "RunTime", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<Neon.Fun.Signage.SignageContentType>(ref _ContentType, reload) || changed;
            changed = base.MapProperty<bool>(ref _IsEnabled, reload) || changed;
            changed = base.MapProperty<string>(ref _MinimumPlayerVersion, reload) || changed;
            changed = base.MapProperty<TimeSpan>(ref _RunTime, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Signage.SignageContentProperties)obj;

            if (other == null)
            {
                return false;
            }

            if (this.ContentType != other.ContentType)
            {
                return false;
            }

            if (this.IsEnabled != other.IsEnabled)
            {
                return false;
            }

            if (this.MinimumPlayerVersion != other.MinimumPlayerVersion)
            {
                return false;
            }

            if (this.RunTime != other.RunTime)
            {
                return false;
            }

            return true;
        }

        public Neon.Fun.Signage.SignageContentType ContentType
        {
            get { return _ContentType.Value; }
            set { _ContentType.Value = value; }
        }

        public bool IsEnabled
        {
            get { return _IsEnabled.Value; }
            set { _IsEnabled.Value = value; }
        }

        public string MinimumPlayerVersion
        {
            get { return _MinimumPlayerVersion.Value; }
            set { _MinimumPlayerVersion.Value = value; }
        }

        public TimeSpan RunTime
        {
            get { return _RunTime.Value; }
            set { _RunTime.Value = value; }
        }
    }
}

namespace Neon.Fun
{
    public partial class Task : Entity
    {
        //-----------------------------------------------------------------
        // Static members

        private const string typeString     = "nf.task";
        private const string typePathString = typeString;

        private static Dictionary<string, string> propertyNameMap =
            new Dictionary<string, string>()
            {
                { "assignees", "Assignees" },
                { "description", "Description" },
                { "due", "DueDate" },
                { "summary", "Summary" },
            };

        public static EntityRegistration _GetRegistration()
        {
            return new EntityRegistration(typeof(Task), "nf.task",
                (jObject, context) =>
                {
                    return new Task(jObject, context);
                });
        }

        public static bool operator ==(Task entity1, Task entity2)
        {
            return object.Equals(entity1, entity2);
        }

        public static bool operator !=(Task entity1, Task entity2)
        {
            return !object.Equals(entity1, entity2);
        }

        //-----------------------------------------------------------------
        // Instance members

        private LinkListMapper<Neon.Fun.Account> _Assignees;
        private SimpleMapper<string>             _Description;
        private SimpleMapper<DateTime>           _DueDate;
        private SimpleMapper<string>             _Summary;

        public Task()
            : this(new JObject())
        {
        }

        public Task(JObject jObject, IEntityContext context = null, bool load = true, Dictionary<string, string> derivedPropertyNameMap = null)
            : base(derivedPropertyNameMap ?? propertyNameMap, context)
        {
            _Assignees   = new LinkListMapper<Neon.Fun.Account>(this, "assignees", "Assignees", context);
            _Description = new SimpleMapper<string>(this, "description", "Description", context);
            _DueDate     = new SimpleMapper<DateTime>(this, "due", "DueDate", context);
            _Summary     = new SimpleMapper<string>(this, "summary", "Summary", context);

            if (load)
            {
                _Load(jObject, reload: false);
            }
        }

        public override string _GetEntityType()
        {
            return typeString;
        }

        public virtual Neon.Fun.EntityTypes EntityType
        {
            get { return Neon.Fun.EntityTypes.Task; }
        }

        public override bool _Load(JObject jObject, bool reload = false, bool setType = true)
        {
            var changed = false;

            base._Load(jObject);

            changed = base.MapProperty<Neon.Fun.Account>(ref _Assignees, reload) || changed;
            changed = base.MapProperty<string>(ref _Description, reload) || changed;
            changed = base.MapProperty<DateTime>(ref _DueDate, reload) || changed;
            changed = base.MapProperty<string>(ref _Summary, reload) || changed;

            if (setType)
            {
                jObject["+tp"] = typePathString;
                jObject["+t"] = typeString;
            }

            return changed;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (object.ReferenceEquals(this, obj))
            {
                return true;
            }

            var other = (Neon.Fun.Task)obj;

            if (other == null)
            {
                return false;
            }

            if (!NeonHelper.SequenceEqual(this.Assignees, other.Assignees))
            {
                return false;
            }

            if (this.Description != other.Description)
            {
                return false;
            }

            if (this.DueDate != other.DueDate)
            {
                return false;
            }

            if (this.EntityType != other.EntityType)
            {
                return false;
            }

            if (this.Summary != other.Summary)
            {
                return false;
            }

            return true;
        }

        public IList<Neon.Fun.Account> Assignees
        {
            get { return _Assignees.Value; }
            set { _Assignees.Set(value); }
        }

        public string Description
        {
            get { return _Description.Value; }
            set { _Description.Value = value; }
        }

        public DateTime DueDate
        {
            get { return _DueDate.Value; }
            set { _DueDate.Value = value; }
        }

        public string Summary
        {
            get { return _Summary.Value; }
            set { _Summary.Value = value; }
        }
    }
}

#endregion Entities

//-----------------------------------------------------------------------------

#region Binder Documents

namespace Neon.Fun.Signage
{
    public partial class SignageContentDocument : EntityDocument<Neon.Fun.Signage.SignageContentProperties>, IEntityDocument
    {
        //---------------------------------------------------------------------
        // Static members

        internal static void _Register()
        {
            EntityDatabase.Register<SignageContentDocument>(
                (document)                       => new SignageContentDocument(document),
                (properties, database, revision) => new SignageContentDocument(properties, database, revision),
                new string[]
                {
                    "package",
                });
        }

        //---------------------------------------------------------------------
        // Instance members

        private SignageContentDocument(Document document)
            : base(document)
        {
            AttachmentEvent += OnAttachmentEvent;
        }

        private SignageContentDocument(IDictionary<string, object> properties, EntityDatabase database, Revision revision)
            : base(properties, database, revision)
        {
            AttachmentEvent += OnAttachmentEvent;
        }

        private void OnAttachmentEvent(object sender, AttachmentEventArgs args)
        {
            if (args.Name == "package" && args.Path != Package)
            {
                Package = args.Path;

                if (args.Notify)
                {
                    OnPropertyChanged("Package");
                }
            }
        }

        public string Package { get; private set; }

        public void SetPackage(byte[] bytes, string contentType = null)
        {
            base.SetAttachment("package", bytes, contentType);
        }

        public void SetPackage(Stream input, string contentType = null)
        {
            base.SetAttachment("package", input, contentType);
        }

        public Attachment GetPackage()
        {
            return base.GetAttachment("package");
        }

        public void RemovePackage()
        {
            base.RemoveAttachment("package");
        }
    }
}

#endregion Binder Documents

//-----------------------------------------------------------------------------

#region Included Types

namespace Neon.Fun
{
    public enum EmailUses : System.Int32
    {
        Other = 0,
        Home = 1,
        Work = 2,
    }
}

namespace Neon.Fun
{
    public enum EntityTypes : System.Int32
    {
        Email = 0,
        Person = 1,
        Phone = 2,
        Location = 3,
        LatLon = 4,
        Account = 5,
        Employee = 6,
        Customer = 7,
        Organization = 8,
        Casino = 9,
        Restaurant = 10,
        Task = 11,
        BowlingLeague = 12,
        BowlingProShop = 13,
        BowlingCenter = 14,
        BowlingLane = 15,
        BowlingBallSpecification = 16,
        BowlingBallDetails = 17,
        SignageContentProperties = 18,
        SignageContentPlayList = 19,
    }
}

namespace Neon.Fun
{
    public enum LocationUses : System.Int32
    {
        Other = 0,
        Mailing = 1,
        Billing = 2,
        Corporate = 3,
        Retail = 4,
    }
}

namespace Neon.Fun
{
    public enum PhoneUses : System.Int32
    {
        Other = 0,
        Home = 1,
        HomeFax = 2,
        Work = 3,
        WorkFax = 4,
        Pager = 5,
    }
}

namespace Neon.Fun.Signage
{
    public enum SignageContentType : System.Int32
    {
        Unknown = 0,
        Slideshow = 1,
    }
}

namespace Neon.Fun
{
    public enum UserRoles : System.Int32
    {
        Other = 0,
        Guest = 1,
        Customer = 2,
        Employee = 3,
        Admin = 4,
        Supervisor = 5,
        Finance = 6,
    }
}

#endregion Included Types

//-----------------------------------------------------------------------------

#region Registration

namespace Neon.Fun
{
    public static class ModelTypes
    {
        public static void Register()
        {
            // Entity registrations

            var registrations = new List<EntityRegistration>(50);

            registrations.Add(Neon.Fun.Account._GetRegistration());
            registrations.Add(Neon.Fun.Bowling.BallSummary._GetRegistration());
            registrations.Add(Neon.Fun.Bowling.BowlingCenter._GetRegistration());
            registrations.Add(Neon.Fun.Bowling.Lane._GetRegistration());
            registrations.Add(Neon.Fun.Bowling.League._GetRegistration());
            registrations.Add(Neon.Fun.Bowling.ProShop._GetRegistration());
            registrations.Add(Neon.Fun.Casino._GetRegistration());
            registrations.Add(Neon.Fun.Customer._GetRegistration());
            registrations.Add(Neon.Fun.Email._GetRegistration());
            registrations.Add(Neon.Fun.Employee._GetRegistration());
            registrations.Add(Neon.Fun.LatLon._GetRegistration());
            registrations.Add(Neon.Fun.Location._GetRegistration());
            registrations.Add(Neon.Fun.Models.Person._GetRegistration());
            registrations.Add(Neon.Fun.Organization._GetRegistration());
            registrations.Add(Neon.Fun.Phone._GetRegistration());
            registrations.Add(Neon.Fun.Restaurant._GetRegistration());
            registrations.Add(Neon.Fun.Signage.SignageContentPlayList._GetRegistration());
            registrations.Add(Neon.Fun.Signage.SignageContentProperties._GetRegistration());
            registrations.Add(Neon.Fun.Task._GetRegistration());

            Entity.Register(registrations);

            // Binder (AKA derived document) registrations

            Neon.Fun.Signage.SignageContentDocument._Register();
        }
    }
}

#endregion Registration

